import java.util.*;
import java.io.*;

class Node {
	int idx = -1;
	Node parent;
	List<Node> Children = new ArrayList<>(0);
	
	Node(int idx, Node parent){
		this.idx = idx;
		this.parent = parent;
	}

	public Node getParent() {
		return parent;
	}

	public void setParent(Node parent) {
		this.parent = parent;
	}

	public List<Node> getChildren() {
		return Children;
	}

	public void addChild(Node child) {
		this.Children.add(child);
	}
	
	
}

public class Boj1967Tree {
	
	public static int res = 0;
	public static void main(String[] args) throws Exception{
		// TODO Auto-generated method stub
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st;
		int N = Integer.parseInt(br.readLine());
		Node[] nodeList = new Node[N+1];
		
//		root노드

		
//		Node rootNode = new Node(1, null);
//		nodeList[1] = rootNode;
		
		for(int i=1; i<N+1; ++i) {
			Node node = new Node(i, null);
			nodeList[i] = node;
		}
		Node rootNode = nodeList[1];
		
//		int[][] weight = new int[N+1][N+1];
		int[] weight = new int[N+1]; //자식의 인덱스 - 부모는 유일

		
		for(int i=0; i<N-1; ++i) {
			st = new StringTokenizer(br.readLine());
			
			int parent = Integer.parseInt(st.nextToken());
			int child = Integer.parseInt(st.nextToken());
			int val = Integer.parseInt(st.nextToken());
			
			weight[child] = val;
			Node ParentNode = nodeList[parent];
//			Node childNode = new Node(child, ParentNode);
//			nodeList[child] = childNode;
			Node childNode = nodeList[child];
			
			ParentNode.addChild(childNode);
			
			
			
			
			
			
			
			
			
		}
		
		// 리턴 : 최대 길이 직선, 
		// 자식의 값들을 비교하면서 최대값 반환 and 자식 두개의 합을 전역 max와 비교
		//중간 노드의 지름보다 리프노드의 지름이 더 크다
		// 재귀로 노드의 지름 구하기
		
		maxLen(rootNode, weight);
		System.out.println(res);
		
		
	}
	
	
	private static int maxLen(Node nowNode, int[] weight) {
		int childrenSize = nowNode.Children.size();
		if(childrenSize == 0) {
			return 0;
		}
		if(childrenSize == 1) {
			Node child = nowNode.Children.get(0);
			int now = maxLen(child, weight) + weight[child.idx];
			res = Math.max(res, now);
			return now;
		}
		
		
		int[] childLenList = new int[childrenSize];
		for(int i=0; i<childrenSize; ++i) {
			Node child = nowNode.Children.get(i);
			childLenList[i] = maxLen(child, weight) + weight[child.idx];
		}
		
//		Arrays.sort(childLenList, Collections.reverseOrder());
		Arrays.sort(childLenList);

		// 전역 max
		res = Math.max(res, childLenList[childrenSize-1] + childLenList[childrenSize-2]);
		
		return childLenList[childrenSize-1];

	}

}



